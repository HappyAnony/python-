参考文档：http://www.cnblogs.com/alex3714/articles/5876749.html



IO操作模型：[参考文档：https://segmentfault.com/a/1190000003063859]
（1）同步                       wait for data[数据从硬盘等硬件到内存内核态]           copy data from kernel to user[数据从内核态到用户态]       模块
    1.1 阻塞IO                     单线程阻塞                                                 单线程阻塞
    1.2 非阻塞IO                   单线程非阻塞                                                单线程阻塞
    1.3 IO多路复用                 单线程多并发阻塞                                             单线程多并发阻塞
（2）异步
    2.1 异步IO                     非阻塞                                                      非阻塞                                     asyncio[python3]

注意：异步IO底层实现复杂，同时使用场景比较少，所以很多所谓的异步IO都是IO多路复用

 IO多路复用的实现模式：[参考文档：http://www.cnblogs.com/alex3714/p/4372426.html]
               使用状况            是否跨平台                                         特点
 （1）Select   较常用               跨平台            单个进程能够监视的文件描述符的数量存在最大限制[默认1024;linux上可以通过ulimit -SHn 65535修改文件描述符数量]；随着文件描述符数量的增大，存储大量文件描述符的数据结构的复制开销也线性增长
 （2）Poll     不常用               跨平台            解决第一个问题；随着文件描述符数量的增大，存储大量文件描述符的数据结构的复制开销也线性增长[扫描获取已就绪的文件描述符]
 （3）Epoll    常用、目前最流行      类Unix平台        以上所有问题都解决了[事件驱动：注册回调通知已就绪的文件描述符]